<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/codemix/babel-plugin-typecheck">babel-plugin-typecheck (v3.9.0)</a>
</h1>
<h4>Transforms flow type annotations into runtime type checks.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.babel-plugin-typecheck">module babel-plugin-typecheck</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.babel-plugin-typecheck.default">
            function <span class="apidocSignatureSpan">babel-plugin-typecheck.</span>default
            <span class="apidocSignatureSpan">(_ref)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">babel-plugin-typecheck.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">babel-plugin-typecheck.</span>inferers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">babel-plugin-typecheck.</span>old_index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">babel-plugin-typecheck.</span>type_checks</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.babel-plugin-typecheck.index">module babel-plugin-typecheck.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.babel-plugin-typecheck.index.default">
            function <span class="apidocSignatureSpan">babel-plugin-typecheck.index.</span>default
            <span class="apidocSignatureSpan">(_ref102)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.babel-plugin-typecheck.inferers">module babel-plugin-typecheck.inferers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.babel-plugin-typecheck.inferers.default">
            function <span class="apidocSignatureSpan">babel-plugin-typecheck.inferers.</span>default
            <span class="apidocSignatureSpan">(_ref)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.babel-plugin-typecheck.old_index">module babel-plugin-typecheck.old_index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.babel-plugin-typecheck.old_index.default">
            function <span class="apidocSignatureSpan">babel-plugin-typecheck.old_index.</span>default
            <span class="apidocSignatureSpan">(_ref)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.babel-plugin-typecheck.type_checks">module babel-plugin-typecheck.type_checks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.babel-plugin-typecheck.type_checks.default">
            function <span class="apidocSignatureSpan">babel-plugin-typecheck.type_checks.</span>default
            <span class="apidocSignatureSpan">(_ref)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">babel-plugin-typecheck.type_checks.</span>INVALID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">babel-plugin-typecheck.type_checks.</span>NEEDS_CHECK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">babel-plugin-typecheck.type_checks.</span>STATICALLY_VERIFIED</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.babel-plugin-typecheck" id="apidoc.module.babel-plugin-typecheck">module babel-plugin-typecheck</a></h1>


    <h2>
        <a href="#apidoc.element.babel-plugin-typecheck.default" id="apidoc.element.babel-plugin-typecheck.default">
        function <span class="apidocSignatureSpan">babel-plugin-typecheck.</span>default
        <span class="apidocSignatureSpan">(_ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function (_ref){var t=_ref.types;var template=_ref.template; /**
* Binary Operators that can only produce boolean results.
*/var BOOLEAN_BINARY_OPERATORS=['==','===','&gt;=','&lt;=','&gt;','&lt;','instanceof'];var checks=createChecks();var staticChecks=createStaticChecks
();var checkIsArray=expression('Array.isArray(input)');var checkIsMap=expression('input instanceof Map');var checkIsSet=expression
('input instanceof Set');var checkIsClass=expression('typeof input ===\'function\' &amp;&amp; input.prototype &amp;&amp; input.prototype.constructor === input');var checkIsGenerator=expression('typeof input === \'function\' &amp;&amp; input.generator');var checkIsIterable=expression('input &amp;&amp; (typeof input[Symbol.iterator] === \'function\' || Array.isArray(input))');var checkIsObject=expression('input != null &amp;&amp; typeof input === \'object\'');var checkNotNull=expression('input != null');var checkEquals=expression('input === expected');var declareTypeChecker=template('\n    const id = (function () {\n      function id (input) {\n        return check;\n      };\n      Object.defineProperty(id, Symbol.hasInstance, {\n        value: function (input) {\n          return id(input);\n        }\n      });\n      return id;\n    })();\n  ');var guard=template('\n    if (!check) {\n      throw new TypeError(message);\n    }\n  ');var thrower=template('\n    if (check) {\n      ret;\n    }\n    else {\n      throw new TypeError(message);\n    }\n  ');var guardInline=expression('\n    (id =&gt; {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    })(input)\n  ');var guardFn=expression('\n    function name (id) {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    }\n  ');var readableName=expression('\n    inspect(input)\n  ');var checkMapKeys=expression('\n    input instanceof Map &amp;&amp; Array.from(input.keys()).every(key =&gt; keyCheck)\n  ');var checkMapValues=expression('\n    input instanceof Map &amp;&amp; Array.from(input.values()).every(value =&gt; valueCheck)\n  ');var checkMapEntries=expression('\n    input instanceof Map &amp;&amp; Array.from(input).every(([key, value]) =&gt; keyCheck &amp;&amp; valueCheck)\n  ');var checkSetEntries=expression('\n    input instanceof Set &amp;&amp; Array.from(input).every(value =&gt; valueCheck)\n  ');var checkObjectIndexers=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      if (~fixedKeys.indexOf(key)) {\n        return true;\n      }\n      else {\n        return check;\n      }\n    });\n  ');var checkObjectIndexersNoFixed=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      return check;\n    });\n  ');var propType=expression('\n    (function(props, name, component) {\n      var prop = props[name];\n      if(!check) {\n        return new Error(\n          "Invalid prop `" + name + "` supplied to `" + component\n          + "`.\\n\\nExpected:\\n" + expected + "\\n\\nGot:\\n" + got + "\\n\\n"\n        );\n      }\n    })\n  ');var PRAGMA_IGNORE_STATEMENT=/typecheck:\s*ignore\s+statement/i;var PRAGMA_IGNORE_FILE=/typecheck:\s*ignore\s+file/i;function skipEnvironment(comments,opts){if(!opts.only){return false;}var envs=pragmaEnvironments(comments);return !opts.only.some(function(env){return envs[env];});}function pragmaEnvironments(comments){var pragma=/@typecheck:\s*(.+)/;var environments={};comments.forEach(function(comment){var m=comment.value.match(pragma);if(m){m[1].split(',').forEach(function(env){return environments[env.trim()]=true;});}});return environments;}var visitors={Statement:function Statement(path){maybeSkip(path);},TypeAlias:function TypeAlias(path){if(maybeSkip(path)){return;}path.replaceWith(createTypeAliasChecks(path));},InterfaceDeclaration:function InterfaceDeclaration(path){if(maybeSkip(path)){return;}path.replaceWith(createInterfaceChecks(path));},ExportNamedDeclaration:function ExportNamedDeclaration(path){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;if(node.declaration&amp;&amp;node.declaration.type==='TypeAlias'){var declaration=path.get('declaration');declaration.replaceWith(crea ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.babel-plugin-typecheck.index" id="apidoc.module.babel-plugin-typecheck.index">module babel-plugin-typecheck.index</a></h1>


    <h2>
        <a href="#apidoc.element.babel-plugin-typecheck.index.default" id="apidoc.element.babel-plugin-typecheck.index.default">
        function <span class="apidocSignatureSpan">babel-plugin-typecheck.index.</span>default
        <span class="apidocSignatureSpan">(_ref102)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function (_ref102){var t=_ref102.types;var template=_ref102.template; /**
* Binary Operators that can only produce boolean results.
*/var BOOLEAN_BINARY_OPERATORS=['==','===','&gt;=','&lt;=','&gt;','&lt;','instanceof'];if(!(Array.isArray(BOOLEAN_BINARY_OPERATORS)&amp;&amp;BOOLEAN_BINARY_OPERATORS
.every(function(item){return typeof item==='string';}))){throw new TypeError('Value of variable "BOOLEAN_BINARY_OPERATORS" violates
 contract.\n\nExpected:\nstring[]\n\nGot:\n'+_inspect(BOOLEAN_BINARY_OPERATORS));}var checks=createChecks();var staticChecks=createStaticChecks();var checkIsArray=expression('Array.isArray(input)');if(!(typeof checkIsArray==='function')){throw new TypeError('Value of variable "checkIsArray" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsArray));}var checkIsMap=expression('input instanceof Map');if(!(typeof checkIsMap==='function')){throw new TypeError('Value of variable "checkIsMap" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsMap));}var checkIsSet=expression('input instanceof Set');if(!(typeof checkIsSet==='function')){throw new TypeError('Value of variable "checkIsSet" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsSet));}var checkIsClass=expression('typeof input === \'function\' &amp;&amp; input.prototype &amp;&amp; input.prototype.constructor === input');if(!(typeof checkIsClass==='function')){throw new TypeError('Value of variable "checkIsClass" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsClass));}var checkIsGenerator=expression('typeof input === \'function\' &amp;&amp; input.generator');if(!(typeof checkIsGenerator==='function')){throw new TypeError('Value of variable "checkIsGenerator" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsGenerator));}var checkIsIterable=expression('input &amp;&amp; (typeof input[Symbol.iterator] === \'function\' || Array.isArray(input))');if(!(typeof checkIsIterable==='function')){throw new TypeError('Value of variable "checkIsIterable" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsIterable));}var checkIsObject=expression('input != null &amp;&amp; typeof input === \'object\'');if(!(typeof checkIsObject==='function')){throw new TypeError('Value of variable "checkIsObject" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsObject));}var checkNotNull=expression('input != null');if(!(typeof checkNotNull==='function')){throw new TypeError('Value of variable "checkNotNull" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkNotNull));}var checkEquals=expression('input === expected');if(!(typeof checkEquals==='function')){throw new TypeError('Value of variable "checkEquals" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkEquals));}var declareTypeChecker=template('\n    const id = (function () {\n      function id (input) {\n        return check;\n      };\n      Object.defineProperty(id, Symbol.hasInstance, {\n        value: function (input) {\n          return id(input);\n        }\n      });\n      return id;\n    })();\n  ');if(!(typeof declareTypeChecker==='function')){throw new TypeError('Value of variable "declareTypeChecker" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(declareTypeChecker));}var guard=template('\n    if (!check) {\n      throw new TypeError(message);\n    }\n  ');if(!(typeof guard==='function')){throw new TypeError('Value of variable "guard" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(guard));}var thrower=template('\n    if (check) {\n      ret;\n    }\n    else {\n      throw new TypeError(message);\n    }\n  ');if(!(typeof thrower==='function')){throw new TypeError('Value of variable "thrower" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(thrower));}var guardInline=expression('\n    (id =&gt; {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    })(input)\n  ');if(!(typeof guardInline==='function')){throw new TypeError('Value of variable "guardInline" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_ins ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.babel-plugin-typecheck.inferers" id="apidoc.module.babel-plugin-typecheck.inferers">module babel-plugin-typecheck.inferers</a></h1>


    <h2>
        <a href="#apidoc.element.babel-plugin-typecheck.inferers.default" id="apidoc.element.babel-plugin-typecheck.inferers.default">
        function <span class="apidocSignatureSpan">babel-plugin-typecheck.inferers.</span>default
        <span class="apidocSignatureSpan">(_ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function make(_ref) {
  var t = _ref.types;
  var template = _ref.template;

  var INFERENCE_TYPES = {};

<span class="apidocCodeCommentSpan">  /**
   * Register a new type inference for the given node type.
   */
</span>  function register(type, fn) {
    INFERENCE_TYPES[type] = fn;
  }

  /**
   * Infer the type of the given node path and return an annotation.
   */
  function inferType(path) {
    var inferer = INFERENCE_TYPES[path.type];
    if (inferer) {
      return inferer(path);
    } else {
      console.log('Unsupported Type: ' + path.type);
      return path.getTypeAnnotation() || t.anyTypeAnnotation();
    }
  }

  function lookupGlobalIdentifier(name) {
    switch (name) {
      case 'Symbol':
        return t.functionTypeAnnotation(null, [], null, t.anyTypeAnnotation());
        return t.functionTypeAnnotation(null, [t.functionTypeParam(t.identifier('key'), t.stringTypeAnnotation())], null, t.anyTypeAnnotation
() //t.genericTypeAnnotation(t.identifier('Symbol'))
        );
      default:
        return t.anyTypeAnnotation();
    }
  }

  register('ObjectExpression', function (path) {
    var _path$get$reduce = path.get('properties').reduce(function (_ref2, prop) {
      var _ref3 = _slicedToArray(_ref2, 2);

      var properties = _ref3[0];
      var indexers = _ref3[1];

      if (prop.node.computed) {
        var keyType = inferType(prop.get('key'));
        if (keyType.type === 'AnyTypeAnnotation') {
          keyType = t.stringTypeAnnotation();
        }
        indexers.push(t.objectTypeIndexer(t.identifier('key'), keyType, inferType(prop.get('value'))));
      } else {
        properties.push(t.objectTypeProperty(prop.node.key, inferType(prop.get('value'))));
      }
      return [properties, indexers];
    }, [[], []]);

    var _path$get$reduce2 = _slicedToArray(_path$get$reduce, 2);

    var properties = _path$get$reduce2[0];
    var indexers = _path$get$reduce2[1];


    return t.objectTypeAnnotation(properties, indexers);
  });

  register('CallExpression', function (path) {
    var callee = path.get('callee');
    var annotation = inferType(callee);
    dump(annotation);
    return t.anyTypeAnnotation();
  });

  register('Identifier', function (path) {
    var binding = path.scope.getBinding(path.node.name);
    if (!binding) {
      return lookupGlobalIdentifier(path.node.name);
    } else {
      console.log(binding);
    }
  });

  return inferType;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.babel-plugin-typecheck.old_index" id="apidoc.module.babel-plugin-typecheck.old_index">module babel-plugin-typecheck.old_index</a></h1>


    <h2>
        <a href="#apidoc.element.babel-plugin-typecheck.old_index.default" id="apidoc.element.babel-plugin-typecheck.old_index.default">
        function <span class="apidocSignatureSpan">babel-plugin-typecheck.old_index.</span>default
        <span class="apidocSignatureSpan">(_ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function (_ref){var t=_ref.types;var template=_ref.template; /**
* Binary Operators that can only produce boolean results.
*/var BOOLEAN_BINARY_OPERATORS=['==','===','&gt;=','&lt;=','&gt;','&lt;','instanceof'];var checks=createChecks();var staticChecks=createStaticChecks
();var checkIsArray=expression('Array.isArray(input)');var checkIsMap=expression('input instanceof Map');var checkIsSet=expression
('input instanceof Set');var checkIsClass=expression('typeof input ===\'function\' &amp;&amp; input.prototype &amp;&amp; input.prototype.constructor === input');var checkIsGenerator=expression('typeof input === \'function\' &amp;&amp; input.generator');var checkIsIterable=expression('input &amp;&amp; (typeof input[Symbol.iterator] === \'function\' || Array.isArray(input))');var checkIsObject=expression('input != null &amp;&amp; typeof input === \'object\'');var checkNotNull=expression('input != null');var checkEquals=expression('input === expected');var declareTypeChecker=template('\n    const id = (function () {\n      function id (input) {\n        return check;\n      };\n      Object.defineProperty(id, Symbol.hasInstance, {\n        value: function (input) {\n          return id(input);\n        }\n      });\n      return id;\n    })();\n  ');var guard=template('\n    if (!check) {\n      throw new TypeError(message);\n    }\n  ');var thrower=template('\n    if (check) {\n      ret;\n    }\n    else {\n      throw new TypeError(message);\n    }\n  ');var guardInline=expression('\n    (id =&gt; {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    })(input)\n  ');var guardFn=expression('\n    function name (id) {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    }\n  ');var readableName=expression('\n    inspect(input)\n  ');var checkMapKeys=expression('\n    input instanceof Map &amp;&amp; Array.from(input.keys()).every(key =&gt; keyCheck)\n  ');var checkMapValues=expression('\n    input instanceof Map &amp;&amp; Array.from(input.values()).every(value =&gt; valueCheck)\n  ');var checkMapEntries=expression('\n    input instanceof Map &amp;&amp; Array.from(input).every(([key, value]) =&gt; keyCheck &amp;&amp; valueCheck)\n  ');var checkSetEntries=expression('\n    input instanceof Set &amp;&amp; Array.from(input).every(value =&gt; valueCheck)\n  ');var checkObjectIndexers=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      if (~fixedKeys.indexOf(key)) {\n        return true;\n      }\n      else {\n        return check;\n      }\n    });\n  ');var checkObjectIndexersNoFixed=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      return check;\n    });\n  ');var propType=expression('\n    (function(props, name, component) {\n      var prop = props[name];\n      if(!check) {\n        return new Error(\n          "Invalid prop `" + name + "` supplied to `" + component\n          + "`.\\n\\nExpected:\\n" + expected + "\\n\\nGot:\\n" + got + "\\n\\n"\n        );\n      }\n    })\n  ');var PRAGMA_IGNORE_STATEMENT=/typecheck:\s*ignore\s+statement/i;var PRAGMA_IGNORE_FILE=/typecheck:\s*ignore\s+file/i;function skipEnvironment(comments,opts){if(!opts.only){return false;}var envs=pragmaEnvironments(comments);return !opts.only.some(function(env){return envs[env];});}function pragmaEnvironments(comments){var pragma=/@typecheck:\s*(.+)/;var environments={};comments.forEach(function(comment){var m=comment.value.match(pragma);if(m){m[1].split(',').forEach(function(env){return environments[env.trim()]=true;});}});return environments;}var visitors={Statement:function Statement(path){maybeSkip(path);},TypeAlias:function TypeAlias(path){if(maybeSkip(path)){return;}path.replaceWith(createTypeAliasChecks(path));},InterfaceDeclaration:function InterfaceDeclaration(path){if(maybeSkip(path)){return;}path.replaceWith(createInterfaceChecks(path));},ExportNamedDeclaration:function ExportNamedDeclaration(path){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;if(node.declaration&amp;&amp;node.declaration.type==='TypeAlias'){path.replaceWith(t.exportNamedDeclaration(createTypeAliasChecks(path ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.babel-plugin-typecheck.type_checks" id="apidoc.module.babel-plugin-typecheck.type_checks">module babel-plugin-typecheck.type_checks</a></h1>


    <h2>
        <a href="#apidoc.element.babel-plugin-typecheck.type_checks.default" id="apidoc.element.babel-plugin-typecheck.type_checks.default">
        function <span class="apidocSignatureSpan">babel-plugin-typecheck.type_checks.</span>default
        <span class="apidocSignatureSpan">(_ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function make(_ref) {
  var t = _ref.types;

  var ANNOTATION_TYPES = {};

  registerAnnotationType('VoidTypeAnnotation', {
    compatible: ['VoidTypeAnnotation', 'NullableTypeAnnotation'],
    checkAnnotation: function checkAnnotation(expected, candidate) {
      if (candidate.type === 'VoidTypeAnnotation') {
        return STATICALLY_VERIFIED;
      } else {
        return NEEDS_CHECK;
      }
    },
    checkValue: function checkValue(expected, candidate) {
      if (t.isIdentifier(candidate) &amp;&amp; candidate.node.name === 'undefined') {
        return STATICALLY_VERIFIED;
      } else {
        switch (candidate.type) {
          case 'NullLiteral':
          case 'ThisExpression':
          case 'NewExpression':
          case 'ObjectExpression':
          case 'ArrayExpression':
          case 'FunctionExpression':
          case 'ArrowFunctionExpression':
          case 'BooleanLiteral':
          case 'NumericLiteral':
          case 'StringLiteral':
          case 'RegExpLiteral':
            return INVALID;
          case 'Identifier':
            return candidate.node.name === 'undefined' ? INVALID : NEEDS_CHECK;
          default:
            return NEEDS_CHECK;
        }
      }
    },
    runtime: function runtime(expected, id) {
      return id + ' === undefined';
    }
  });

  registerAnnotationType('NullLiteralTypeAnnotation', {
    compatible: ['NullLiteralTypeAnnotation', 'NullableTypeAnnotation'],
    checkAnnotation: function checkAnnotation(expected, candidate) {
      if (candidate.type === 'NullLiteralTypeAnnotation') {
        return STATICALLY_VERIFIED;
      } else {
        return NEEDS_CHECK;
      }
    },
    checkValue: function checkValue(expected, candidate) {
      if (candidate.type === 'Identifier' &amp;&amp; candidate.node.name === 'undefined') {
        return INVALID;
      } else if (candidate.type === 'NullLiteral') {
        return STATICALLY_VERIFIED;
      } else {
        switch (candidate.type) {
          case 'ThisExpression':
          case 'NewExpression':
          case 'ObjectExpression':
          case 'ArrayExpression':
          case 'FunctionExpression':
          case 'ArrowFunctionExpression':
          case 'BooleanLiteral':
          case 'NumericLiteral':
          case 'StringLiteral':
          case 'RegExpLiteral':
            return INVALID;
          default:
            return NEEDS_CHECK;
        }
      }
    },
    runtime: function runtime(expected, id) {
      return id + ' === null';
    }
  });

  registerLiteralAnnotationType('Boolean');
  registerLiteralAnnotationType('Numeric');
  registerLiteralAnnotationType('String');

  registerAnnotationType('NullableTypeAnnotation', {
    compatible: ['NullableTypeAnnotation', 'NullLiteralTypeAnnotation', 'VoidTypeAnnotation']

  });

<span class="apidocCodeCommentSpan">  /**
   * Register an annotation type with the given name / config.
   */
</span>  function registerAnnotationType(name, config) {
    ANNOTATION_TYPES[name] = config;
  }

  /**
   * Register a literal annotation type.
   */
  function registerLiteralAnnotationType(shortName) {

    var typeName = shortName + 'Literal';
    var annotationName = shortName + 'TypeAnnotation';
    var literalAnnotationName = typeName + 'TypeAnnotation';

    registerAnnotationType(literalAnnotationName, {
      compatible: [literalAnnotationName, annotationName],
      checkAnnotation: function checkAnnotation(expected, candidate) {
        if (candidate.type === literalAnnotationName) {
          if (candidate.value === expected.value) {
            return STATICALLY_VERIFIED;
          } else {
            return INVALID;
          }
        } else {
          return NEEDS_CHECK;
        }
      },
      checkValue: function checkValue(expected, candidate) {
        if (candidate.type === typeName) {
          if (candidate.value === expected.value) {
            return STATICALLY_VERIFIED;
          } else {
            return INVALID;
          }
        } else {
          switch (candidate.type) {
            case 'NullLiteral':
            case 'ThisExpression':
            case 'NewExpression': ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>